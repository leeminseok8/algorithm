# 알고리즘 기록

### 알고리즘 문제를 하루 1문제를 목표로, 해결하지 못하더라도 더 나은 코드를 작성하기 위해 진행
<br>

# 프로그래머스

<strong>13.자릿수 더하기</stront>
- return 값에서 짧은 수식을 이용하기 위해 다른 생각없이 for문만 사용하려고 했다. 그 결과, 실행 속도 측면에서 비효율적인 결과가 나타났다.<br>
<br>그러나 다른 사람의 풀이를 봤을 때 재귀함수를 이용한 로직 설계가 있었다. 코드를 실행해보니 속도 측면에서 0.02ms가 0.00ma로 몇배의 차이가 존재했다.<br>
<br>앞으로 단순히 문제를 통과하기 보다 속도나 메모리 측면으로 생각하고 개발자다운 마인드로 생각하는 연습을 해야겠다. 또한, 이유없이 for문을 사용해서는 안되겠다는 생각을 했다.

<strong>14.소수 찾기</stront>
- 소수를 구하는 수학 공식을 알지 못해서 다른 로직으로 설계했지만 결국 while, for문을 사용한 코드를 작성했다. 결과적으로, 정확성 테스트는 시간을 초과했고 효율성은 부적합 판정을 받았다. 수학적 논리사고를 향상시켜 다양한 로직 구현이 필요해 보인다. ( 다른 풀이를 찾으면 업데이트 할 예정 )

<strong>17.문자열 다루기 기본</stront>
- 문제 이름답게 문자열을 어떻게 하면 쉽게 다룰 수 있는지 배운 문제였다. 유니코드를 사용하여 숫자와 문자열을 나누는 기준을 잡았지만, 다른 사람의 문제풀이에서 isdigit이라는 method를 알게 되었다. 알고리즘은 다양한 해결 방안이 있지만, 아는 방법'만'으로 로직을 짜는 것보다 효율적인 method를 공부하고 활용하여 문제를 해결하는 방식으로 공부하자.

<strong>24.같은 숫자는 싫어</stront>
- 배열 arr에 arr[-1]을 사용하여 마지막 인덱스와 다음 인덱스를 비교하려고 했는데, 빈 배열에 인덱스 값을 호출하면 IndexError가 발생한다는 것을 알게 되었다. 그래서 0번 인덱스를 배열에 담아 debug를 했는데, 다른 사람의 풀이를 확인하니 arr[-1:]으로 슬라이싱을 했다. 슬라이싱은 빈 배열을 그대로 배열의 형태로 반환하여 에러가 발생하지 않았다. 인덱싱과 슬라이싱의 차이를 기억하자.

<strong>31.3진법 뒤집기</stront>
- 예외처리를 다 했지만, 1번 항목에서만 런타임 에러가 발생했다. 정확한 이유는 특정하지 못했지만, python에서 list를 호출하면 속도가 느리다고 알고 있는데 '''n은 1 이상 100,000,000 이하인 자연수입니다.''' 이 제한사항을 볼 때 문제에서 제한하는 호출 시간을 초과하며 런타임 에러가 발생했다고 생각한다. 그래서 list를 사용하지 않고 아래의 방식으로 런 하면 런타임 에러 없이 동작한다. 필요한 경우가 아니라면 list의 사용을 최소화 하자.